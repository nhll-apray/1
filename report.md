# PW7 实验报告

PB19000115 冯子烨 PB19000123 李云琪 PB19000124 李泽林

## 必做部分

### Part1 公共子表达式删除

**B1-1** 请说明你实现的公告子表达式删除算法的设计思路。

* local_cse()函数实现对公共子表达式的删除,但由于存在类似如下的情况(第一次无法消除d和c的公共子表达式),需要多次执行local_cse直至无法删除

  * ```c++
    a=3;
    b=a+3;
    c=b*4;
    d=a+3;
    e=d*4;
    ```


* 每次删除公共子表达式时,对每个块维护一个可删除的表达式的集合new_val(用于删除重复的数值表达式),gep_inst(用于删除重复的gep指令),这个集合由他的前缀块来更新,每次处理完一个块后将该块携带的集合插入到他的后缀块的集合内
* 删除一个块的子表达式时需要保证他的所有前缀块都已被删除子表达式,利用递归并对块的访问次数进行统计很容易处理
* 注意数值存在const,不能只比较指针是否相等,需要用dynamic_cast判断是不是constantint,每次删除子表达式时使用replace_all_use_with函数

**B1-2** 若要将call指令、load指令列入公共子表达式删除的考虑范围，除了你实现的公共子表达式删除算法，还需要考虑哪些其他因素？

* 记录call指令的参数,以及call的函数是否存在使用变化的全局变量的情况,否则无法删除
* load指令需要记录load的全局变量和数组元素是否发生过变化

### Part2 活跃变量分析

**B2-1** 请说明你实现的活跃变量分析算法的设计思路。
* 在 `map <BasicBlock*, std::set<Value*>> IN, OUT, USE, DEF` 中分别存储每个基本块的 IN, OUT, use, def 集合, 其中 use 集合不包含 phi 指令中所使用的变量.
* 在 `std::map <BasicBlock*, std::map<BasicBlock*, std::set<Value*>>> PHI;` 中存储每个基本块的 phi 指令中一共会出现哪些基本块, 所对应使用的变量是哪些.
* 用类似书算法9.2的循环迭代求解每个基本块的 IN 和 OUT, 修改 OUT 的公式为$\rm OUT[B] =\cup_{S是B的后继}(use_S\cup PHI[B,S]\cup(OUT[S]-def_S))$, 修改 IN 的公式为 $\rm OUT[B] = use_S\cup PHI[B]\cup(OUT[S]-def_S))$


### Part3 支配树

**B3-1** 证明：若 x 和 y 支配 b，则要么 x 支配 y，要么 y 支配 x。
- 假设 x 不支配 y，从 Entry 到 b 必经过 y，从 Entry 到 y 可以不经过 x。假设 CFG 中存在从 y 到 b 的路径不经过 x，那么存在路径从 Entry 到 y 不经过 x 且从 y 到 b 不经过 x，则该路径从 Entry 到 b 不经过 x，与前提 “x 支配 b” 矛盾；那么从 y 到 b 的路径必经过 x，一定存在一条从 y 到 b 的简单路径（没有环）经过 x，则该路径中从 x 到 b 不经过 y。如果存在从 Entry 到 x 的路径不经过 y，那么也存在从 Entry 到 b 的路径不经过 y，与前提 “y 支配 b” 矛盾；所以任何从 Entry 到 x 的路径都经过 y，即 y 支配 x。反之同理，所以若 x 和 y 支配 b，则要么 x 支配 y，要么 y 支配 x。

**B3-2** `Figure 1: The Iterative Dominator Algorithm` 是用于计算支配关系的迭代算法，该算法的内层 `for` 循环是否一定要以后序遍历的逆序进行，为什么？
- 不需要，使 `while` 循环得以继续的条件是有节点的 `Dom[n]` 集合有所改变。
所有的 `Dom[n]` 集合都一定是所有顶点集合 $V$ 的子集。根据初始化条件 `DOM[n] ← {1 . . . N }` 以及更新操作 `new_set ← (⋂ p∈preds(n) (DOM[p])) ⋃ {n}`可知，每一次更新操作都会使 `Dom[n]` 集合中元素数量减少，一定存在一个稳定状态。只要某个顶点暂时不处于稳定的状态上，在循环中一定会发生改变，这时 `while` 不会终止，所以不管按照什么顺序最后都可以达到稳定状态结束 `while` 循环。
根据论文中的讨论，迭代算法将发现最大不动点解并停止。由于该框架是分布式的，最大不动点解与满足所有路径的解相同，这也符合支配集的定义。

**B3-3** `Figure 3: The Engineered Algorithm` 为计算支配树的算法。在其上半部分的迭代计算中，内层的 `for` 循环是否一定要以后序遍历的逆序进行，为什么？
- 不一定需要按照后序遍历的逆序进行，包括同样的图可以有不同的后续遍历方法。
每一次 `doms` 的改变都向记录逆序数更大的方向发展，所以最终一定会停留在一个稳定点。而且，该算法本质上与 `Figure 1` 的算法没有区别，所以不一定严格按照后序遍历的逆序进行。但是按照后序遍历的逆序可以带来更高的效率。

**B3-4** `Figure 3: The Engineered Algorithm` 为计算支配树的算法。其中下半部分 `intersect` 的作用是什么？内层的两个 `while` 循环中的小于号能否改成大于号？为什么？
- 作用是求支配树中两个节点到开始节点路径上公共的、后序最小的节点编号，即找到离它们最近的公共支配节点。
- 不能，因为节点的编号是按照后序遍历定义的。
在这种情况下，比较是在后序编号上进行的；对于每个交点，我们从两个集合的末端开始两个 `finger`，我们将指向较小数字的手指向后移动一个元素，直到 `finger` 指向相同的后序数字。因为支配树中较高的节点具有较高的后序数，所以要改变值较小的 `finger`。


**B3-5**. 这种通过构建支配树从而得到支配关系的算法相比教材中算法 9.6 在时间和空间上的优点是什么？
- **时间** 可以估计算法 9.6 每一次迭代总成本为 $O(E · N)$；而构建支配树每次迭代的总成本为 $O(N + E ·D)$，其中 $D$ 是最大支配集的大小，同时它也通过避免为每个节点分配和初始化单独的支配集来节省时间。
- **空间** 算法 9.6 中，如果存储每个节点所有的支配集需要复杂度为 $O(N^2)$；而构建支配树只需要维持 $O(N)$ 的数组，它通过共享表示来节省空间，只需要存储 $IDom(b)$ 一个节点，而不是存储所有支配集中的节点。

**B3-6** 在反向支配树的构建过程中，是怎么确定 EXIT 结点的？为什么不能以流图的最后一个基本块作为 EXIT 结点？
- 确定 EXIT 结点：遍历每一个基本块，直到找到某一个基本块有返回，利用 `terminate_instr->is_ret()` 判断。
- 带有返回语句的基本块才可能是函数的出口，流图的最后一个基本块不一定是函数的出口，所以“以流图的最后一个基本块作为 EXIT 结点”是不正确的。



## 选做部分




